import DB from '../include/DB.js'
import { Part } from '../include/part.js';
import { Markup } from '../include/bey.js';

let META, PARTS;
let [comp, line] = [...new URLSearchParams(location.search)][0] ?? [];

const Parts = () => Parts.firstly().then(Parts.before).then(Parts.display).then(Parts.after).then(Parts.finally);
Object.assign(Parts, {
    count: () => Q('.part-result').value = Q('x-part:not([id^="+"]):not([hidden])', []).length,
    async firstly () {
        [META, PARTS] = await DB.get.essentials();
        Part.import(META.general, PARTS);
        line ||= META.grouped[comp].所有 ? '所有' : '一體';
        META = {
            types: META.general.types, 
            filters: META.grouped[comp].filters, 
            ...META.grouped[comp][line]
        };
        Parts.place = Q('section');
        Magnifier();
    },
    before: () => Filter(),
    display: () => DB.get.parts(/^.X$/.test(line) ? line : comp)
        .then(parts => Promise.all(parts.map(json => new Part(json).tile())))
        .then(parts => Parts.place.replaceChildren(...parts)),

    after () {
        let hash = decodeURI(location.hash.substring(1));
        Parts.switch(hash && Q(`x-part[id='${hash}']`) || hash);
        Q(`#${Storage('pref')?.sort || 'name'}`).click();
    },
    finally: () => Q('.loading').classList.remove('loading'),
    
    switch (groupORpart) {
        let [group, part] = typeof groupORpart == 'string' ? [groupORpart] : [, groupORpart.Part];
        group ??= part.path[2] ?? part.group;
        group && Q(`dl#group input`, input => input.checked = input.value == `.${group}`);
        group ||= Q('dl#group input:checked').value?.substring(1);
        Filter.filter();
        Parts.info(group);
        typeof groupORpart == 'object' && Parts.focus(groupORpart);
    },
    info (group) {
        document.title = document.title.replace(/^.*?(?= ■ )/, META.title?.[group] ?? META.title ?? '');
        let info = comp + (/^\w+$/.test(line) ? `.${line}` : '');
        Q('details').hidden = !(Q('details p').innerHTML = Markup.spacing(Q(`[id='${info}']`)?.innerHTML));
    },
    focus (tile) {
        Q('.target')?.classList.remove('target');
        tile.classList.add('target');
        setTimeout(() => tile.scrollIntoView(), 500);
    }
});
onhashchange = () => Parts.after();

const Magnifier = () => {
    Q('nav output').before(Magnifier.create());
    Q(`#${Storage('pref')?.button || 'mag2'}`).checked = true;
    Magnifier.events();
};
Object.assign(Magnifier, {
    create: () => E(`div.part-mag`, [
        E('continuous-knob', {min: .75, max: 2, value: Storage('pref')?.knob || 1}, E('i.center', '')),
        ...E.radios([.54, .81, 1.6].map((value, i) => ({id: `mag${i}`, name: 'mag', value}) ))
    ]),
    events () {
        Q('.part-mag').oninput = ({target}) => {
            E(Parts.place).set({'--font': target.value});
            Storage('pref', target instanceof HTMLInputElement ? {button: target.id} : {knob: target.value});
        }
        setTimeout(onresize = Magnifier.switch);
    },
    switch: () => E(Parts.place).set({'--font': (innerWidth > 630 ? Q('continuous-knob') : Q('[name=mag]:checked')).value})
});

const Filter = function(type) {
    return this instanceof Filter ? 
        this.create(type).events().dl :
        Q('nav menu').after(...['group', ...META.filters ?? []].map(f => new Filter(f)), Sorter());
};
Object.assign(Filter.prototype, {
    create (type) {
        this.type = type;
        let dl = new O(Filter.dl[type]()).map(([_, inputs]) => [_, 
            E.checkboxes(inputs.map(({label, value, checked}) => new A(label, {value: value.replace(/^(?=\w)/, '.'), checked}) ))
        ]);
        this.dl = E.dl(dl, {id: type, classList: [`part-filter`, type == 'group' ? comp : '']});
        this.inputs = [this.dl.Q('input')].flat();
        type != 'group' && this.inputs.forEach(input => input.checked = true);
        return this;
    },
    events () {
        this.dl.Q('dt').onclick = () => {
            if (this.type == 'group' && META.multiple === false) return;
            this.inputs.forEach(input => input.checked = true);
            Filter.filter(this.type == 'group');
        }
        this.dl.onchange = ({target: input}) => {
            this.inputs.forEach(i => i.checked = i == input);
            this.type == 'group' ? Parts.switch(input.value.substring(1)) : Filter.filter(this.type == 'group');
        };
        return this;
    }
});
Object.assign(Filter, {
    dl: {
        group: () => ({[line]: META.group.flatMap(([value, {label, checked}]) => ({value, label, checked})) }),
        type:  () => ({類型: META.types.map(t => ({value: t, label: E('img', {src: `../img/types.svg#${t}`})}) )}),
        spin:  () => ({迴轉: ['left','right'].map((s, i) => ({value: s, label: ['\ue01d','\ue01e'][i]}) )}),
        prefix:() => ({變化: [{value: Filter.unprefix(), label: '–'}, ...META.variety.flatMap(([label, value]) => ({value, label}))] }),
    },
    filter () {
        let query = Q('.part-filter[id]:not([hidden])', []).reduce((obj, dl) => ({
            ...obj, [dl.id]: [...dl.Q(':checked', []).map(i => i.value)].join()
        }), {});
        query.type += `,${Filter.untype()}`;
        [...Parts.place.children].forEach(tile => 
            !(tile.hidden = Object.values(query).some(classes => !tile.matches(classes))) && tile.fill()
        );
        Parts.count();
    },
    untype: () => `:not(.${META.types.join(',.')})`,
    unprefix: () => `:not(${Object.values(META.variety)})`
});

const Sorter = () => {
    let inputs = new O({name: '\ue034', weight: '\ue036', time: '\ue035'});
    let dl = E.dl({
        排序: E.radios([...inputs].map(([id, icon]) => new A(icon, { name: 'sort', id })))
    }, {
        classList: `part-sorter`, 
        onchange ({target: input}) {
            let sorted = [...Parts.place.children].map(tile => tile.Part).sort(Sorter.sort[input.id]);
            Parts.place.append(...[...Parts.place.children]
                .sort((a, b) => sorted.indexOf(a.Part) - sorted.indexOf(b.Part)));
            input.checked && Storage('pref', {sort: input.id});
        }
    });
    Sorter.getSchedule(comp);
    return dl;
}
Object.assign(Sorter, {
    compare: (u, v, f = p => p) => +(f(u) > f(v)) || -(f(u) < f(v)),
    sort: {
        name: (p, q) =>
            [p.group, q.group].includes('remake') && Sorter.compare(p, q, p => p.group)
            || Sorter.compare(p, q, p => parseInt(p.abbr))
            || Sorter.compare(p, q, p => p.abbr.toLowerCase()),

        weight: (p, q) => Sorter.compare(q, p, p => (w => parseInt(w) + Sorter.weight[w.at(-1)])(p.stat[0] || '0=')),
        
        time: (p, q) => Sorter.compare(p, q, p =>
            Sorter.getSchedule()[Sorter.index.blade[p.group] ?? 0].findIndex(abbr => abbr == p.abbr) * -1
        )
    },
    getSchedule: comp => Sorter.schedule ?? DB.get('product', 'beys')
        .then(beys => beys.reverse()
            .map(bey => bey[2].split(' ')[Sorter.index.full[comp]]?.split('.'))
            .filter(subs => subs?.length === (/.X$/.test(line) ? 3 : 1))
        ).then(list => Sorter.schedule = list[0].map((_, i) => [...new Set(list.map(row => row[i]))] )),
    index: {
        full: {blade: 0, ratchet: 1, bit: 2},
        blade: {motif: 0, upper: 1, lower: 2}
    },
    weight: {'+': .2, '=': 0, '-': -.2}
});
export default Parts
